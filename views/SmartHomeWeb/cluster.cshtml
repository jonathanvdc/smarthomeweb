@using System
@using System.Collections.Generic
@using Nancy.Security
@using SmartHomeWeb
@using SmartHomeWeb.Model
@using Nancy.ViewEngines.Razor
@inherits NancyRazorViewBase<IEnumerable<Location>>

<div class="container" style="margin-top: 50px">
	<div class="row">
		<div id="location_select" class="col_lg_12">
			<select onchange="getSensors(this.value)">
				@foreach (var x in Model)
				{
					<option value="@x.Id">
						@x.Data.Name
					</option>
				}
			</select>
		</div>
	</div>
	<div class="row">
		<div id="chart_div" class="col_lg_8">
			<!-- Graph goes here -->
		</div>
		<div id="steps" class="col_lg_4">
		  <b>Current iteration: </b><p id="currentiteration">0</p>
		  <b>Low usage: </b><p id="firstlimit">0</p>
		  <b>Medium usage: </b><p id="secondlimit">0</p>
		  <b>High usage: </b><p id="thirdlimit">0</p>
		</div>
		<button onclick="kmeans()">Apply kmeans</button>
	</div>
</div>

<script type="text/javascript" src="https://www.gstatic.com/charts/loader.js"></script>

<script type="text/javascript">
	var sensorlist = [];
	var lowmean = 0;
	var midmean = 0;
	var highmean = 0;
	
	// Load the Visualization API and the corechart package.
    google.charts.load('current', {'packages':['corechart']});

    // Callback that creates and populates a data table,
    // instantiates the pie chart, passes in the data and
    // draws it.
	function kmeans(){
	  var newlowmean = 0;
	  var newmidmean = 0;
	  var newhighmean = 0;
	  lowcount = 0;
	  midcount = 0;
	  highcount = 0;
	  for(var i = 0; i < sensorlist.length; ++i){
	    var distancelow = Math.abs(sensorlist[i][1] - lowmean);
		var distancemid = Math.abs(sensorlist[i][1] - midmean);
		var distancehigh = Math.abs(sensorlist[i][1] - highmean);
		var lowest = Math.min(distancelow, distancemid, distancehigh);
		if(lowest == distancelow){
		  newlowmean = newlowmean + sensorlist[i][1];
		  ++lowcount;
		  sensorlist[i][2] = "#05F228";
		}else if(lowest == distancemid){
		  newmidmean = newmidmean + sensorlist[i][1];
		  ++midcount;
		  sensorlist[i][2] = "#FFD903";		
		}else{
		  newhighmean = newhighmean + sensorlist[i][1];
		  ++highcount;
		  sensorlist[i][2] = "#FF5447";		
		}
	  }
	  //calculate new means with centroids(or averages because 1d)
	  lowmean = lowcount != 0 ? Math.round(newlowmean*100/lowcount)/100 : lowmean;
	  midmean = midcount != 0 ? Math.round(newmidmean*100/midcount)/100 : midmean;
	  highmean = highcount != 0 ? Math.round(newhighmean*100/highcount)/100 : highmean;
	  updatemeanlines();
	  updateDisplay();
	  drawChart();
	}
	
	function updatemeanlines(){
	  for(var i = 0; i < sensorlist.length; ++i){
	    sensorlist[i][3] = lowmean;
	    sensorlist[i][4] = midmean;	  
	    sensorlist[i][5] = highmean;	  
	  }
	}
	
	function updateDisplay(){
	  document.getElementById('firstlimit').innerHTML = lowmean;
	  document.getElementById('secondlimit').innerHTML = midmean;
	  document.getElementById('thirdlimit').innerHTML = highmean;
	}
	
    function drawChart() {
      // Create the data table.
      var data = new google.visualization.DataTable();
	  updateDisplay();
      data.addColumn('string', 'Sensorname');
      data.addColumn('number', 'Measurement');
	  data.addColumn({ type: 'string', role: 'style' });
	  data.addColumn('number', 'Low mean');
	  data.addColumn('number', 'Mid Mean');
	  data.addColumn('number', 'High Mean');
      data.addRows(sensorlist);

      // Set chart options
      var options = {'title':'How Much Pizza I Ate Last Night',
                     'width':600,
                     'height':450,
					 seriesType: 'bars',
					 series: {
					 1: {type: 'line',enableInteractivity: false, color: "#05F228"},
					 2: {type: 'line',enableInteractivity: false, color: "#FFD903"},
					 3: {type: 'line',enableInteractivity: false, color: "#FF5447"},
					 }
					};

      // Instantiate and draw our chart, passing in some options.
      var chart = new google.visualization.ComboChart(document.getElementById('chart_div'));
      chart.draw(data, options);
    }
	  
	function addcolors(){
	  //Add the initial colors for each measurement belonging to the correct cluster
	  //Also adds the mean of the clusters to display these in the graph
	  for(var i = 0; i < sensorlist.length; ++i){
	    if(sensorlist[i][1] <= lowmean){
		  sensorlist[i].push("#05F228");		  
		}else if(sensorlist[i][1] <= midmean){
		  sensorlist[i].push("#FFD903");		
		}else{
		  sensorlist[i].push("#FF5447");
		}
		sensorlist[i].push(lowmean);
		sensorlist[i].push(midmean);
		sensorlist[i].push(highmean);
	  }
	}
	
	
	function getMonthlyMeasurement(sensorid){
		var xhttp = new XMLHttpRequest();
		xhttp.open("GET", "/api/month-average/"+sensorid.toString() + "/2016-04-01T00:00:00", false);
		xhttp.send();
		measured = JSON.parse(xhttp.responseText);
		return Math.round(measured.measurement*100)/100;
	};
	
	function getSensors(id){
		sensorlist = [];
		var xhttp = new XMLHttpRequest();
		xhttp.onreadystatechange = function() {
			if (xhttp.readyState == 4) {
			   sensors = JSON.parse(xhttp.responseText);
			   for(var i = 0; i < sensors.length; i++)
			   {
				 sensorlist.push([sensors[i].data.name, getMonthlyMeasurement(sensors[i].id)]);
			   }
			   sensorlist.sort(function(a, b) {
                return a[1] > b[1] ? 1 : -1;
               });
			   var difference = sensorlist[sensorlist.length - 1][1] - sensorlist[0][1];
			   var interval = difference/3;
			   
			   //Set each cluster to 1/3 of the usage
			   lowmean = Math.round((sensorlist[0][1] + (interval/2))*100)/100;
			   midmean = Math.round((lowmean + interval)*100)/100;
			   highmean = Math.round((midmean + interval)*100)/100;
			   addcolors();
			   drawChart();
			}
		};
		xhttp.open("GET", "/api/sensors/at-location/" + id.toString(), true);
		xhttp.send();
	}
</script>