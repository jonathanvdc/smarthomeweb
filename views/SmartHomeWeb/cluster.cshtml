@using System
@using System.Collections.Generic
@using Nancy.Security
@using SmartHomeWeb
@using SmartHomeWeb.Model
@using Nancy.ViewEngines.Razor
@inherits NancyRazorViewBase<IEnumerable<Location>>

<!-- Include Date Range Picker -->
<script type="text/javascript" src="//cdn.jsdelivr.net/momentjs/latest/moment.min.js"></script>
<script type="text/javascript" src="//cdn.jsdelivr.net/bootstrap.daterangepicker/2/daterangepicker.js"></script>
<link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/bootstrap.daterangepicker/2/daterangepicker.css" />

<div class="container" style="margin-top: 50px">
	<div class="row">
		<div id="location_select" class="col_lg_12">
			<select onchange="getSensors(this.value)">
				@foreach (var x in Model)
				{
					<option value="@x.Id">
						@x.Data.Name
					</option>
				}
			</select>
			
			<input id="daterange" name="daterange" size="5" style="margin-left: 20px;">
		</div>
	</div>
	<div class="row">
		<div id="chart_div" class="col_lg_8">
			<!-- Graph goes here -->
		</div>
		<div id="steps" class="col_lg_4">
		  <table>
		    <tr>
		      <td style="padding: 5px;"><b>Current iteration: </b></td>
			  <td id="currentiteration">0</td>
		    </tr>
			<tr>
		      <td style="padding: 5px;"><b>Low usage: </b></td>
			  <td id="firstlimit">0</td>
			  <td style="padding: 5px;padding-left:20px;"><b>Low usage wcss: </b></td>
			  <td id="firstinner">0</td>
		    </tr>
		    <tr>
		      <td style="padding: 5px;"><b>Medium usage: </b></td>
			  <td id="secondlimit">0</td>
			  <td style="padding: 5px;padding-left:20px;"><b>Middle usage wcss: </b></td>
			  <td id="secondinner">0</td>
			</tr>
		    <tr>
		      <td style="padding: 5px;"><b>High usage: </b></td>
			  <td id="thirdlimit">0</td>
			  <td style="padding: 5px;padding-left:20px;"><b>high usage wcss: </b></td>
			  <td id="thirdinner">0</td>
		    </tr>
			<tr>
			  <td style="padding: 5px;"><b>Total wcss:</b></td>
			  <td id="totwcss">0</td>
			</tr>
		  </table>
		</div>
		<button onclick="kmeans()">Apply kmeans</button>
	</div>
</div>

<script type="text/javascript" src="https://www.gstatic.com/charts/loader.js"></script>

<script type="text/javascript">

    var now = new Date();
    $(function () {
        $('input[name="daterange"]').daterangepicker({
            locale: {
                format: 'YYYY/MM'
            },
			singleDatePicker: true,
            autoApply: true,
            linkedCalendars: false,
			showDropdowns: true,
        }, function (start, end, label) {
            var date1 = new Date(start.format('YYYY-MM-DDTHH:mm:ss'));
			now = date1;
			if(currenthousehold >= 0){
			  getSensors(currenthousehold);
			}
        });
    });

</script>

<script type="text/javascript">
	var sensorlist = [];
	var lowmean = 0;
	var midmean = 0;
	var highmean = 0;
	var lowwcss = 0;
	var midwcss = 0;
	var highwcss = 0;
	var currenthousehold = -1;
	var currentiteration = 0;
	// Load the Visualization API and the corechart package.
    google.charts.load('current', {'packages':['corechart']});

    // Callback that creates and populates a data table,
    // instantiates the pie chart, passes in the data and
    // draws it.
	function kmeans(){
	  ++currentiteration; 
	  var newlowmean = 0;
	  var newmidmean = 0;
	  var newhighmean = 0;
	  lowwcss = 0;
	  midwcss = 0;
	  highwcss = 0;
	  lowcount = 0;
	  midcount = 0;
	  highcount = 0;
	  for(var i = 0; i < sensorlist.length; ++i){
	    var distancelow = Math.pow(sensorlist[i][1] - lowmean, 2);
		var distancemid = Math.pow(sensorlist[i][1] - midmean, 2);
		var distancehigh = Math.pow(sensorlist[i][1] - highmean, 2);
		var lowest = Math.min(distancelow, distancemid, distancehigh);
		if(lowest == distancelow){
		  newlowmean = newlowmean + sensorlist[i][1];
		  lowwcss = lowwcss + distancelow;
		  ++lowcount;
		  sensorlist[i][2] = "#05F228";
		}else if(lowest == distancemid){
		  newmidmean = newmidmean + sensorlist[i][1];
		  midwcss = midwcss + distancemid;
		  ++midcount;
		  sensorlist[i][2] = "#FFD903";		
		}else{
		  newhighmean = newhighmean + sensorlist[i][1];
		  highwcss = highwcss + distancehigh;
		  ++highcount;
		  sensorlist[i][2] = "#FF5447";		
		}
	  }
	  //calculate new means with centroids(or averages because 1d)
	  lowmean = lowcount != 0 ? Math.round(newlowmean*100/lowcount)/100 : lowmean;
	  midmean = midcount != 0 ? Math.round(newmidmean*100/midcount)/100 : midmean;
	  highmean = highcount != 0 ? Math.round(newhighmean*100/highcount)/100 : highmean;
	  updatemeanlines();
	  updateDisplay();
	  drawChart();
	}
	
	function updatemeanlines(){
	  for(var i = 0; i < sensorlist.length; ++i){
	    sensorlist[i][3] = lowmean;
	    sensorlist[i][4] = midmean;	  
	    sensorlist[i][5] = highmean;	  
	  }
	}
	
	function updateDisplay(){
	  document.getElementById('firstlimit').innerHTML = lowmean;
	  document.getElementById('secondlimit').innerHTML = midmean;
	  document.getElementById('thirdlimit').innerHTML = highmean;
	  document.getElementById('firstinner').innerHTML = Math.round(lowwcss*100)/100;
	  document.getElementById('secondinner').innerHTML = Math.round(midwcss*100)/100;
	  document.getElementById('thirdinner').innerHTML = Math.round(highwcss*100)/100;
	  document.getElementById('totwcss').innerHTML = Math.round((lowwcss+midwcss+highwcss)*100)/100;
	}
	
    function drawChart() {
      // Create the data table.
      var data = new google.visualization.DataTable();
	  updateDisplay();
      data.addColumn('string', 'Sensorname');
      data.addColumn('number', 'Measurement');
	  data.addColumn({ type: 'string', role: 'style' });
	  data.addColumn('number', 'Low mean');
	  data.addColumn('number', 'Mid Mean');
	  data.addColumn('number', 'High Mean');
      data.addRows(sensorlist);

      // Set chart options
      var options = {'title':'How Much Pizza I Ate Last Night',
                     'width':600,
                     'height':450,
					 seriesType: 'bars',
					 series: {
					 1: {type: 'line',enableInteractivity: false, color: "#05F228"},
					 2: {type: 'line',enableInteractivity: false, color: "#FFD903"},
					 3: {type: 'line',enableInteractivity: false, color: "#FF5447"},
					 }
					};

      // Instantiate and draw our chart, passing in some options.
      var chart = new google.visualization.ComboChart(document.getElementById('chart_div'));
      chart.draw(data, options);
    }
	  
	function addcolors(){
	  //Add the initial colors for each measurement belonging to the correct cluster
	  //Also adds the mean of the clusters to display these in the graph
	  for(var i = 0; i < sensorlist.length; ++i){
	    if(sensorlist[i][1] <= lowmean){
		  sensorlist[i].push("#05F228");		  
		}else if(sensorlist[i][1] <= midmean){
		  sensorlist[i].push("#FFD903");		
		}else{
		  sensorlist[i].push("#FF5447");
		}
		sensorlist[i].push(lowmean);
		sensorlist[i].push(midmean);
		sensorlist[i].push(highmean);
	  }
	}
	
	
	function getMonthlyMeasurement(sensorid){
		var xhttp = new XMLHttpRequest();
		xhttp.open("GET", "/api/month-average/"+sensorid.toString() + "/" + (now.getFullYear()).toString() + "-" + (now.getMonth()+1).toString() + "-01T00:00:00", false);
		xhttp.send();
		measured = JSON.parse(xhttp.responseText);
		return Math.round(measured.measurement*100)/100;
	};
	
	function getSensors(id){
	    currenthousehold = id;
		sensorlist = [];
		var xhttp = new XMLHttpRequest();
		xhttp.onreadystatechange = function() {
			if (xhttp.readyState == 4) {
			   sensors = JSON.parse(xhttp.responseText);
			   for(var i = 0; i < sensors.length; i++)
			   {
				 sensorlist.push([sensors[i].data.name, getMonthlyMeasurement(sensors[i].id)]);
			   }
			   sensorlist.sort(function(a, b) {
                return a[1] > b[1] ? 1 : -1;
               });
			   var difference = sensorlist[sensorlist.length - 1][1] - sensorlist[0][1];
			   var interval = difference/3;
			   
			   //Set each cluster to 1/3 of the usage
			   lowmean = Math.round((sensorlist[0][1] + (interval/2))*100)/100;
			   midmean = Math.round((lowmean + interval)*100)/100;
			   highmean = Math.round((midmean + interval)*100)/100;
			   addcolors();
			   //Set the initial wcss:
			   for(var i = 0; i < sensorlist.length; ++i){
			     if(sensorlist[i][2] == "#05F228"){
				   lowwcss = lowwcss + Math.pow(sensorlist[i][1] - lowmean, 2);
				 }else if(sensorlist[i][2] == "#FFD903"){
				   midwcss = midwcss + Math.pow(sensorlist[i][1] - midmean, 2);
				 }else{
				   highwcss = highwcss + Math.pow(sensorlist[i][1] - highmean, 2);
				 }
			   }
			   updateDisplay();
			   drawChart();
			}
		};
		xhttp.open("GET", "/api/sensors/at-location/" + id.toString(), true);
		xhttp.send();
	}
</script>