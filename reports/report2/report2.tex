\documentclass[12pt,draft,parskip=full]{article}
\usepackage[utf8]{inputenc}
\usepackage[dutch]{babel}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{array}
\usepackage{longtable}
\usepackage[a4paper]{geometry}
\usepackage[final]{listings}
\usepackage{pxfonts}
\usepackage{relsize}
\usepackage{parskip}
% \usepackage{all_is_fuck}
\begin{document}
\title{Rapport 2}
\author{Sibert Aerts \\ Ken Bauwens \\ Pieter Hendriks \\ Jonathan Van der Cruysse \\ Mauris Van Hauwe}
\maketitle

\newcommand{\code}[1]{\texttt{#1}}
% 
%\newcommand{\CS}{{C\nolinebreak[4]\hspace{-.05em}\raisebox{.4ex}{\relsize{-2}{\textbf{\#}}}}}
\newcommand{\CS}{{C\#}}
\lstset{language=[Sharp]C,basicstyle=\ttfamily}

\section{Status}
We hebben intussen de volgende features ge\"implementeerd:

\begin{itemize}
\item Mauris, Jonathan en Sibert hebben de \textbf{REST API} verzorgd, wat 
inhoudt dat we ruwe JSON data uit de database kunnen requesten en hiernaar 
kunnen posten.

\item Pieter, Jonathan en Mauris hebben de \textbf{database structuur} 
opgesteld. Dit zijn alle huidige tables en de \textit{constraints} die hierop
gedefinieerd zijn.

\item Jonathan en Pieter hebben de interne \textbf{database queries} voorzien, 
die de server gebruikt om data uit de database te lezen en om data weg te 
schrijven naar de database.

\item Sibert, Jonathan, Mauris en Pieter hebben gewerkt aan \textbf{database 
integration}. Dit omvat de meer complexe methodes die data uit de database 
behandelen.

\item Mauris en Pieter hebben \textbf{login}-functionaliteit ge\"implementeerd.

\item Ken, Sibert en Mauris hebben voor \textbf{HTML views} gezorgd

\end{itemize}

\section{Design}

\subsection{Keuzes}
% Korte motivatie van de belangrijkste keuzes in het ontwerp.
\subsubsection{Programmeertaal}
We hebben gekozen voor de programmeertaal \CS{}. Deze taal is vergelijkbaar met
C++, maar is veel expressiever en meer memory-safe. \CS{} ondersteunt ook 
\textit{task-based parallellism}, wat ons toelaat heel eenvoudig requests 
asynchroon af te handelen.

\subsubsection{Framework}
Als framework voor onze web-applicatie gebruiken we \textit{Nancy}. Dit is een 
minimalistisch web-framework ge\"inspireerd door het Ruby-framework 
\textit{Sinatra}. Een Nancy-project bestaat uit modules, waarin we per URL 
defini\"eren hoe requests beantwoord moeten worden:

\begin{lstlisting}[caption=Een \textit{hello world}-applicatie in Nancy]
    public class MyModule : NancyModule {
        public MyModule() { Get["/"] = _ => "Hey!"; }
    }
\end{lstlisting}

\subsubsection{View engine}
We gebruiken het \textit{Razor} view engine om data in onze pagina's te 
verwerken. Hiertoe schrijven we \textit{view templates}: HTML-pagina's waarin 
C\#-code zit. Deze worden gecompileerd, en Nancy vult data in waar nodig.

\lstset{language=HTML}
\begin{lstlisting}[caption=Een simpel voorbeeld van een Razor view, label=razor]
    <h2>Logged in as @CurrentUser.UserName.</h2>
\end{lstlisting}

\subsection{Database schema}
Het ER-diagram is toegevoegd als bijlage (\texttt{erdiagram.png}). Het database schema zelf kan teruggevonden worden in de appendix.

\subsection{UML schema}

Het UML schema zelf is toegevoegd als bijlage (\texttt{uml-diagram.pdf}). De \emph{back-end} bestaat uit de volgende componenten:

\begin{itemize}

\item \textbf{model classes}: het \emph{model} stelt tuples in de database voor. Concreet is het \emph{model} opgesplitst in twee soorten klassen.

\begin{itemize}

\item \textbf{identity classes}: stellen een tuple in de database voor met een unieke \emph{identifier}, die door de \emph{data connection} gegenereerd wordt. Hun data wordt voorgesteld door een instantie van een \emph{data class}. Zo zijn \code{Location}, \code{Person} en \code{Sensor} enkele voorbeelden van \emph{identity classes}.

\item \textbf{data classes}: stellen concrete data voor. Deze data komt niet 
noodzakelijk precies overeen met een tuple in de database, maar altijd wel met 
een bepaalde deelverzameling daarvan, zonder unieke identifier.

Er bestaan twee voorname \emph{use cases} voor deze \emph{data objects}.
Enerzijds worden ze gebruikt om, zij het in samenwerking met een 
  \emph{identity object}, zij het onafhankelijk, informatie uit de database 
  voor te stellen.
Anderzijds kunnen ze ook gebruikt worden om data van objecten die nog 
  toegevoegd moeten worden aan de database -- en dus nog geen unieke 
  \emph{identifier} hebben -- voor te stellen. \code{PersonData}, 
  \code{LocationData} en \code{Measurement} zijn voorbeelden van \emph{data 
  classes}.

\end{itemize}

\item \textbf{data connection}: spant de brug tussen de database en de \emph{back-end}. De \code{DataConnection} klasse opent en sluit de database, en bedient zich van SQL queries om records aan de database toe te voegen, en deze later weer uit de database te halen. \code{DataConnection} vormt een laag abstractie bovenop directe communicatie met de database: database tuples worden meteen vertaald in \emph{model objects}, en omgekeerd.

\item \textbf{Nancy modules}: een \emph{module} voorziet 
\emph{routing}-functionaliteit; elke module geeft een lijst URL's op, en 
bepaalt welke \emph{content} de server doorstuurt of aanvaardt wanneer een HTTP 
\textsc{get}, \textsc{put} of \textsc{post} request voorkomt. Hier wordt geen 
onderscheid gemaakt tussen de API, dat door scripts een applicaties gebruikt 
kan worden, en de HTML pagina's, die in een browser bekeken kunnen worden.

Elke \emph{module} heeft zijn eigen verantwoordelijkheid, en toegang (via de 
API) tot de verschillende \emph{tables} van de database wordt voorzien door 
verschillende modules. De {modules} zelf komen echter nooit direct in 
contact met de database: ze manipuleren enkel \emph{model objects}, en laten 
het communiceren met de database over aan de klasse \code{DataConnection}.

\item \textbf{Configuratie en bootstrapping}: naast interactie met gebruikers en database, bestaan er ook nog enkele \emph{utility classes}, die de configuratie en het opstarten van de server organiseren. Daarnaast voorzien deze klassen ook extra functionaliteit in de vorm van \emph{user login}. 

\end{itemize}
\section{Product}
\subsection{Basisvereisten}
\subsubsection{Back-end}
In de database worden onder andere gebruikers, berichten, sensoren, en locaties 
(i.e.\ huishoudens) 
opgeslagen, samen met de verbanden tussen deze records (bv.\ ``gebruiker A 
woont op locatie B'' of ``gebruikers C en D zijn bevriend''). Ook metingen
worden hier verzameld: elke meetwaarde wordt gekoppeld aan een sensor ID en een 
zekere timestamp.

Een Python script, \texttt{init-db.py}, laadt alle mock-up data in de database 
en communiceert met \textit{ElecSim} om metingen aan te maken. Dit script 
communiceert met onze API, die \textsc{get/put/post} implementeert 
voor de nodige tabellen. Tabel~\ref{api-table}, achteraan dit document, toont 
hoe deze API precies werkt.

\subsubsection{Front-end}
Op de hoofdpagina kunnen gebruikers zich registreren en inloggen. Er is een 
\textit{navigation bar} met links naar hun dashboard, en overzichten van hun 
locaties en sensoren. Gebruikers kunnen ook berichten lezen die ze van anderen 
ontvangen hebben.

Het dashboard laat de gebruiker een locatie en een sensor kiezen, en toont de 
gebruiker een Google Charts-grafiek van die sensor over de gewenste 
tijdsperiode.

\subsection{Extra functionaliteit}

We hebben
\emph{continuous integration} opgezet voor het project. Telkens we een {commit} 
pushen naar onze GitHub {repository}, gaan Travis CI na dat de applicatie correct compileert. Daarnaast wordt 
momenteel ook het cre\"eren van een database en het toevoegen, aggregeren en verwijderen van data automatisch getest. Als een commit de \textit{build} breekt, worden we hiervan op de hoogte gebracht.

\section{Planning}
De basisvereisten zijn al ge\"implementeerd, maar er is nog wat fragmentatie in 
de user interface. We willen vlottere interactie met de grafieken voorzien.

\pagebreak
\newgeometry{margin=2cm}
\section{Appendix: SQL}
\label{dbschema}
\lstset{language=SQL,basicstyle=\ttfamily}
\lstinputlisting{smarthomeweb.sql}

\pagebreak
\restoregeometry
\def\arraystretch{1.8}
\newcommand{\argu}[1]{\textbf{<\textit{#1}>}}
\newcommand{\getallDesc}[1]{Toont een JSON-lijst van alle \code{#1} records.}
\newcommand{\getDesc}[1]{Toont de \code{#1} met de gegeven ID.}
\newcommand{\insertDesc}[1]{Leest een \code{#1{}Data} JSON-object uit de
  request body, en maakt een nieuwe \code{#1} aan in de database.}
\newcommand{\deleteDesc}[1]{Verwijdert de \code{#1} met
  de gegeven ID uit de database.}
\newcommand{\crud}[3]{
  \code{GET /api/{#1}} & \getallDesc{#2} \\
  \code{GET /api/{#1}/\argu{#3}} & \getDesc{#2} \\
  \code{POST /api/{#1}} & \insertDesc{#2} \\
  \code{DELETE /api/{#1}/\argu{#3}} & \deleteDesc{#2}
}

\section{Appendix: API calls}
{\small
  \begin{longtable}{p{.40\textwidth} p{.50\textwidth}}
    \textbf{Commando} & \textbf{Beschrijving} \\
    \hline
    \crud{persons}{Person}{guid} \\
    \hline
    \code{GET /api/friends/}
    & Toont een JSON-lijst van alle \code{Friends} records. \\
    \code{GET /api/friends/\argu{guid}}
    & Toont alle vrienden de \code{Person} met de gegeven GUID. \\
    \code{GET /api/friends/requests /received/\argu{guid}}
    & Toont alle \code{Persons} die de gegeven \code{Person} een 
    vriendschapsverzoek gestuurd hebben. \\
    \code{GET /api/friends/requests /sent/\argu{guid}}
    & Toont alle \code{Persons} waarheen de gegeven \code{Person} een 
    vriendschapsverzoek gestuurd heeft. \\
    \hline
    \crud{locations}{Location}{id} \\
    \hline
    \code{GET /api/has-location}
    & Toont alle koppels $(A, B)$ in de relatie \textit{``persoon A beheert 
    locatie B''}. \\
    \code{GET /api/has-location /locations/\argu{guid}}
    & Toont alle locaties voor de \code{Person} met de gegeven GUID. \\
    \code{GET /api/has-location /persons/\argu{id}}
    & Toont alle persons voor de \code{Location} met de gegeven ID. \\
    \code{POST /api/has-location}
    & Voegt een koppel aan de \textit{has-location} relatie toe. \\
    \hline
    \crud{message}{Message}{id} \\
    \hline
    \crud{sensors}{Sensor}{id} \\
    \hline
    \code{GET /api/sensors/by-tag/\argu{tag}}
    & Toont alle \code{Sensors} met de gegeven tag. \\
    \code{GET /api/sensors /at-location/\argu{id}}
    & Toont alle \code{Sensors} op de gegeven locatie. \\
    \code{GET /api/sensors /at-location/\argu{id} /by-tag/\argu{tag}}
    & Toont alle \code{Sensors} met de gegeven tag op de gegeven locatie. \\
    \code{PUT /api/sensors/\argu{id}}
    & Voert een update uit op de gegeven \code{Sensor}. \\
    \hline 
    \code{GET /api/sensor-tags/\argu{id}}
    & Toont alle tags van de \code{Sensor} met de gegeven ID. \\
    \code{POST /api/sensor-tags/\argu{id}}
    & Voegt een tag toe aan de \code{Sensor} met de gegeven ID. De naam van de 
    tag wordt gelezen als een JSON string. \\
    \code{DELETE /api/sensor-tags/\argu{id}}
    & Verwijdert een tag van de \code{Sensor} met de gegeven ID. De naam van de 
    tag wordt gelezen als een JSON string. \\
    \hline
    \code{GET /api/measurements}
    & Toont een JSON lijst van \textit{alle} metingen in de database. \\
    \code{GET /api/measurements /\argu{id}}
    & Toont alle metingen voor een gegeven \code{Sensor} ID. \\
    \code{GET /api/measurements /\argu{id}/\argu{time}}
    & Toont \'e\'en measurement, voor de gegeven \code{Sensor} op het gegeven 
    tijdstip. \\
    \code{GET /api/measurements /\argu{id}/\argu{from}/\argu{to}}
    & Toont alle metingen voor de gegeven \code{Sensor} tussen de tijdstippen 
    \code{from} en \code{to}. \\
    \code{GET /api/measurements/virtual /\argu{id}/\argu{from}/\argu{to}}
    & ? \\
    \code{POST /api/measurements}
    & Voegt een JSON-lijst van metingen toe aan de database. \\
    \code{PUT /api/measurements /updatetag}
    & ? \\
    \hline
    % Nu /autofit, /compact, /xxx-average, en /frozen nog.
    \label{api-table}
  \end{longtable}
}

\end{document}